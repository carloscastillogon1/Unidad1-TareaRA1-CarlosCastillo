{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PPS Unidad 1 \u2013 Tarea RA1 Carlos Castillo En esta p\u00e1gina se recoge la estructura y acceso a la documentaci\u00f3n de la Tarea RA1. 1. Elementos de Python En este apartado se documentan los elementos de Python utilizados en la pr\u00e1ctica, as\u00ed como el c\u00f3digo comentado desarrollado. Desarrollo completo en: Elementos de Python 2. Ejecuci\u00f3n y Depuraci\u00f3n Se describen los problemas encontrados durante la ejecuci\u00f3n del c\u00f3digo y el proceso de depuraci\u00f3n seguido para solucionarlos, incluyendo capturas de pantalla. Desarrollo completo en: Ejecuci\u00f3n y Depuraci\u00f3n 3. Pruebas En este apartado se explican las pruebas realizadas, los errores detectados, el c\u00f3digo de las pruebas y su ejecuci\u00f3n en el IDE. Desarrollo completo en: Pruebas 4. Ejecuci\u00f3n en Sandbox Se detalla el proceso de ejecuci\u00f3n del programa en un entorno Sandbox, incluyendo capturas del proceso. Desarrollo completo en: Ejecuci\u00f3n en Sandbox 5. Reflexi\u00f3n sobre la infraestructura de seguridad de los lenguajes Reflexi\u00f3n personal sobre la seguridad de Python y su comparaci\u00f3n con otros lenguajes, en relaci\u00f3n con la ejecuci\u00f3n en entornos controlados. Desarrollo completo en: Reflexi\u00f3n","title":"Inicio"},{"location":"#pps-unidad-1-tarea-ra1","text":"Carlos Castillo En esta p\u00e1gina se recoge la estructura y acceso a la documentaci\u00f3n de la Tarea RA1.","title":"PPS Unidad 1 \u2013 Tarea RA1"},{"location":"#1-elementos-de-python","text":"En este apartado se documentan los elementos de Python utilizados en la pr\u00e1ctica, as\u00ed como el c\u00f3digo comentado desarrollado. Desarrollo completo en: Elementos de Python","title":"1. Elementos de Python"},{"location":"#2-ejecucion-y-depuracion","text":"Se describen los problemas encontrados durante la ejecuci\u00f3n del c\u00f3digo y el proceso de depuraci\u00f3n seguido para solucionarlos, incluyendo capturas de pantalla. Desarrollo completo en: Ejecuci\u00f3n y Depuraci\u00f3n","title":"2. Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"#3-pruebas","text":"En este apartado se explican las pruebas realizadas, los errores detectados, el c\u00f3digo de las pruebas y su ejecuci\u00f3n en el IDE. Desarrollo completo en: Pruebas","title":"3. Pruebas"},{"location":"#4-ejecucion-en-sandbox","text":"Se detalla el proceso de ejecuci\u00f3n del programa en un entorno Sandbox, incluyendo capturas del proceso. Desarrollo completo en: Ejecuci\u00f3n en Sandbox","title":"4. Ejecuci\u00f3n en Sandbox"},{"location":"#5-reflexion-sobre-la-infraestructura-de-seguridad-de-los-lenguajes","text":"Reflexi\u00f3n personal sobre la seguridad de Python y su comparaci\u00f3n con otros lenguajes, en relaci\u00f3n con la ejecuci\u00f3n en entornos controlados. Desarrollo completo en: Reflexi\u00f3n","title":"5. Reflexi\u00f3n sobre la infraestructura de seguridad de los lenguajes"},{"location":"ejecucion/","text":"En esta secci\u00f3n. lo que vamos a realizar es la depuraci\u00f3n del c\u00f3digo y la ejecuci\u00f3n del mismo, de esta forma, podremos observar sus errores y corregirlos. El primer paso ser\u00e1 abrir el Visual Studio Code. Una vez dentro, seleccionaremos la carpeta donde se encuentra la app:","title":"Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"ejecucion/#en-esta-seccion-lo-que-vamos-a-realizar-es-la-depuracion-del-codigo-y-la-ejecucion-del-mismo-de-esta-forma-podremos-observar-sus-errores-y-corregirlos","text":"","title":"En esta secci\u00f3n. lo que vamos a realizar es la depuraci\u00f3n del c\u00f3digo y la ejecuci\u00f3n del mismo, de esta forma, podremos observar sus errores y corregirlos."},{"location":"ejecucion/#el-primer-paso-sera-abrir-el-visual-studio-code-una-vez-dentro-seleccionaremos-la-carpeta-donde-se-encuentra-la-app","text":"","title":"El primer paso ser\u00e1 abrir el Visual Studio Code. Una vez dentro, seleccionaremos la carpeta donde se encuentra la app:"},{"location":"pruebas/","text":"","title":"Pruebas"},{"location":"python/","text":"C\u00f3digo Python \u2013 Simulaci\u00f3n de un Lavadero de Coches Introducci\u00f3n Este documento muestra el c\u00f3digo comentado del archivo lavadero.py . El objetivo del programa es simular el comportamiento de un t\u00fanel de lavado de coches , controlando: El estado del lavadero Las fases del lavado Las reglas de negocio El c\u00e1lculo de ingresos Conceptos clave del dise\u00f1o Antes de analizar el c\u00f3digo, es importante comprender los siguientes conceptos: El lavadero solo puede atender a un coche a la vez Cada lavado sigue una secuencia fija de fases Algunas fases son opcionales El precio final depende de los servicios seleccionados Aqu\u00ed est\u00e1 el C\u00f3digo Comentado A continuaci\u00f3n se muestra el c\u00f3digo completo del lavadero, acompa\u00f1ado de comentarios detallados que explican el funcionamiento de cada parte. ```python class Lavadero: \"\"\" Clase que representa un t\u00fanel de lavado de coches. Se encarga de: - Controlar el estado interno del lavadero - Gestionar las fases del lavado - Validar reglas de negocio - Calcular y acumular los ingresos El flujo del lavado se controla mediante una m\u00e1quina de estados. \"\"\" # CONSTANTES DE FASES, cada constante representa una fase del proceso de lavado. FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 def __init__(self): \"\"\" Constructor de la clase Lavadero. Inicializa todas las variables internas del sistema. El lavadero comienza sin coches y sin ingresos. \"\"\" # Dinero total acumulado por los lavados realizados self.__ingresos = 0.0 # Fase actual del lavadero self.__fase = self.FASE_INACTIVO # Indica si el lavadero est\u00e1 ocupado por un coche self.__ocupado = False # Opciones del lavado actual self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False # Se fuerza el estado inicial correcto self.terminar() # PROPIEDADES: Permiten consultar el estado del lavadero sin permitir modificaciones externas. @property def fase(self): \"\"\"Devuelve la fase actual del lavadero.\"\"\" return self.__fase @property def ingresos(self): \"\"\"Devuelve los ingresos acumulados.\"\"\" return self.__ingresos @property def ocupado(self): \"\"\"Indica si el lavadero est\u00e1 ocupado.\"\"\" return self.__ocupado @property def prelavado_a_mano(self): \"\"\"Indica si el lavado incluye prelavado a mano.\"\"\" return self.__prelavado_a_mano @property def secado_a_mano(self): \"\"\"Indica si el lavado incluye secado a mano.\"\"\" return self.__secado_a_mano @property def encerado(self): \"\"\"Indica si el lavado incluye encerado.\"\"\" return self.__encerado # CONTROL DEL CICLO DE LAVADO def terminar(self): \"\"\" Finaliza el ciclo de lavado. Se usa cuando el coche ha terminado todas las fases. El lavadero vuelve a quedar disponible. \"\"\" self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado. Par\u00e1metros: - prelavado_a_mano - secado_a_mano - encerado Reglas de negocio: - No se puede iniciar un lavado si el lavadero est\u00e1 ocupado - No se puede encerar sin secado a mano \"\"\" # Regla 1: solo un coche a la vez if self.__ocupado: raise RuntimeError( \"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\" ) # Regla 2: no se permite encerado sin secado a mano if not secado_a_mano and encerado: raise ValueError( \"No se puede encerar el coche sin secado a mano\" ) # Se inicia el ciclo de lavado self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado # COBRO DEL SERVICIO def _cobrar(self): \"\"\" Calcula el coste del lavado seg\u00fan los servicios seleccionados. Precio base: 5.00 \u20ac Extras: - Prelavado a mano: +1.50 \u20ac - Secado a mano: +1.20 \u20ac - Encerado: +1.00 \u20ac Devuelve el importe cobrado. \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.20 if self.__encerado: coste_lavado += 1.00 # Se suman los ingresos al total self.__ingresos += coste_lavado return coste_lavado # M\u00c1QUINA DE ESTADOS def avanzarFase(self): \"\"\" Avanza el lavadero a la siguiente fase del proceso. Este m\u00e9todo debe llamarse repetidamente para simular el avance del coche dentro del t\u00fanel de lavado. \"\"\" # Si no hay coche, no se hace nada if not self.__ocupado: return # Fase 0: Cobro if self.__fase == self.FASE_INACTIVO: coste = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\"(COBRADO: {coste:.2f} \u20ac)\", end=\"\") # Fase 1: Prelavado o agua elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA # Fase 2: Agua elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA # Fase 3: Jab\u00f3n elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO # Fase 4: Rodillos elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS # Fase 5: Secado elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO # Fases finales: Terminar elif self.__fase in ( self.FASE_SECADO_AUTOMATICO, self.FASE_SECADO_MANO, self.FASE_ENCERADO ): self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}\") # M\u00c9TODOS DE SALIDA def imprimir_fase(self): \"\"\"Muestra por pantalla la fase actual.\"\"\" fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Echando agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Secado a mano\", self.FASE_ENCERADO: \"8 - Encerado\", } print(fases_map.get(self.__fase, \"Estado no v\u00e1lido\"), end=\"\") def imprimir_estado(self): \"\"\"Imprime el estado completo del lavadero.\"\"\" print(\"----------------------------------------\") print(f\"Ingresos acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # M\u00c9TODO AUXILIAR PARA PRUEBAS / TESTS: Este m\u00e9todo NO forma parte del funcionamiento real del lavadero. Su \u00fanico prop\u00f3sito es facilitar pruebas unitarias y # comprobaciones autom\u00e1ticas del flujo de estados del sistema. def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\" Ejecuta un ciclo completo de lavado y devuelve una lista con todas las fases visitadas. Este m\u00e9todo es muy \u00fatil para: - Verificar que el flujo de estados es correcto - Detectar errores en la m\u00e1quina de estados - Realizar pruebas unitarias automatizadas Par\u00e1metros: - prelavado: indica si hay prelavado a mano - secado: indica si hay secado a mano - encerado: indica si hay encerado Retorna: - Lista de enteros con las fases visitadas \"\"\" # Se inicia el lavado con las opciones indicadas self.hacerLavado(prelavado, secado, encerado) # Se guarda la fase inicial fases_visitadas = [self.fase] # Mientras el lavadero est\u00e9 ocupado, seguimos avanzando fases while self.ocupado: # Medida de seguridad para evitar bucles infinitos # en caso de que exista un error en la l\u00f3gica if len(fases_visitadas) > 15: raise Exception( \"Bucle infinito detectado en la simulaci\u00f3n de fases.\" ) # Avanzamos a la siguiente fase self.avanzarFase() # Guardamos la nueva fase alcanzada fases_visitadas.append(self.fase) # Devolvemos la lista completa de fases recorridas return fases_visitadas","title":"Elementos de Python"},{"location":"python/#codigo-python-simulacion-de-un-lavadero-de-coches","text":"","title":"C\u00f3digo Python \u2013 Simulaci\u00f3n de un Lavadero de Coches"},{"location":"python/#introduccion","text":"Este documento muestra el c\u00f3digo comentado del archivo lavadero.py . El objetivo del programa es simular el comportamiento de un t\u00fanel de lavado de coches , controlando: El estado del lavadero Las fases del lavado Las reglas de negocio El c\u00e1lculo de ingresos","title":"Introducci\u00f3n"},{"location":"python/#conceptos-clave-del-diseno","text":"Antes de analizar el c\u00f3digo, es importante comprender los siguientes conceptos: El lavadero solo puede atender a un coche a la vez Cada lavado sigue una secuencia fija de fases Algunas fases son opcionales El precio final depende de los servicios seleccionados","title":"Conceptos clave del dise\u00f1o"},{"location":"python/#aqui-esta-el-codigo-comentado","text":"A continuaci\u00f3n se muestra el c\u00f3digo completo del lavadero, acompa\u00f1ado de comentarios detallados que explican el funcionamiento de cada parte. ```python class Lavadero: \"\"\" Clase que representa un t\u00fanel de lavado de coches. Se encarga de: - Controlar el estado interno del lavadero - Gestionar las fases del lavado - Validar reglas de negocio - Calcular y acumular los ingresos El flujo del lavado se controla mediante una m\u00e1quina de estados. \"\"\" # CONSTANTES DE FASES, cada constante representa una fase del proceso de lavado. FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 def __init__(self): \"\"\" Constructor de la clase Lavadero. Inicializa todas las variables internas del sistema. El lavadero comienza sin coches y sin ingresos. \"\"\" # Dinero total acumulado por los lavados realizados self.__ingresos = 0.0 # Fase actual del lavadero self.__fase = self.FASE_INACTIVO # Indica si el lavadero est\u00e1 ocupado por un coche self.__ocupado = False # Opciones del lavado actual self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False # Se fuerza el estado inicial correcto self.terminar() # PROPIEDADES: Permiten consultar el estado del lavadero sin permitir modificaciones externas. @property def fase(self): \"\"\"Devuelve la fase actual del lavadero.\"\"\" return self.__fase @property def ingresos(self): \"\"\"Devuelve los ingresos acumulados.\"\"\" return self.__ingresos @property def ocupado(self): \"\"\"Indica si el lavadero est\u00e1 ocupado.\"\"\" return self.__ocupado @property def prelavado_a_mano(self): \"\"\"Indica si el lavado incluye prelavado a mano.\"\"\" return self.__prelavado_a_mano @property def secado_a_mano(self): \"\"\"Indica si el lavado incluye secado a mano.\"\"\" return self.__secado_a_mano @property def encerado(self): \"\"\"Indica si el lavado incluye encerado.\"\"\" return self.__encerado # CONTROL DEL CICLO DE LAVADO def terminar(self): \"\"\" Finaliza el ciclo de lavado. Se usa cuando el coche ha terminado todas las fases. El lavadero vuelve a quedar disponible. \"\"\" self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado. Par\u00e1metros: - prelavado_a_mano - secado_a_mano - encerado Reglas de negocio: - No se puede iniciar un lavado si el lavadero est\u00e1 ocupado - No se puede encerar sin secado a mano \"\"\" # Regla 1: solo un coche a la vez if self.__ocupado: raise RuntimeError( \"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\" ) # Regla 2: no se permite encerado sin secado a mano if not secado_a_mano and encerado: raise ValueError( \"No se puede encerar el coche sin secado a mano\" ) # Se inicia el ciclo de lavado self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado # COBRO DEL SERVICIO def _cobrar(self): \"\"\" Calcula el coste del lavado seg\u00fan los servicios seleccionados. Precio base: 5.00 \u20ac Extras: - Prelavado a mano: +1.50 \u20ac - Secado a mano: +1.20 \u20ac - Encerado: +1.00 \u20ac Devuelve el importe cobrado. \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.20 if self.__encerado: coste_lavado += 1.00 # Se suman los ingresos al total self.__ingresos += coste_lavado return coste_lavado # M\u00c1QUINA DE ESTADOS def avanzarFase(self): \"\"\" Avanza el lavadero a la siguiente fase del proceso. Este m\u00e9todo debe llamarse repetidamente para simular el avance del coche dentro del t\u00fanel de lavado. \"\"\" # Si no hay coche, no se hace nada if not self.__ocupado: return # Fase 0: Cobro if self.__fase == self.FASE_INACTIVO: coste = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\"(COBRADO: {coste:.2f} \u20ac)\", end=\"\") # Fase 1: Prelavado o agua elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA # Fase 2: Agua elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA # Fase 3: Jab\u00f3n elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO # Fase 4: Rodillos elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS # Fase 5: Secado elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO # Fases finales: Terminar elif self.__fase in ( self.FASE_SECADO_AUTOMATICO, self.FASE_SECADO_MANO, self.FASE_ENCERADO ): self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}\") # M\u00c9TODOS DE SALIDA def imprimir_fase(self): \"\"\"Muestra por pantalla la fase actual.\"\"\" fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Echando agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Secado a mano\", self.FASE_ENCERADO: \"8 - Encerado\", } print(fases_map.get(self.__fase, \"Estado no v\u00e1lido\"), end=\"\") def imprimir_estado(self): \"\"\"Imprime el estado completo del lavadero.\"\"\" print(\"----------------------------------------\") print(f\"Ingresos acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # M\u00c9TODO AUXILIAR PARA PRUEBAS / TESTS: Este m\u00e9todo NO forma parte del funcionamiento real del lavadero. Su \u00fanico prop\u00f3sito es facilitar pruebas unitarias y # comprobaciones autom\u00e1ticas del flujo de estados del sistema. def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\" Ejecuta un ciclo completo de lavado y devuelve una lista con todas las fases visitadas. Este m\u00e9todo es muy \u00fatil para: - Verificar que el flujo de estados es correcto - Detectar errores en la m\u00e1quina de estados - Realizar pruebas unitarias automatizadas Par\u00e1metros: - prelavado: indica si hay prelavado a mano - secado: indica si hay secado a mano - encerado: indica si hay encerado Retorna: - Lista de enteros con las fases visitadas \"\"\" # Se inicia el lavado con las opciones indicadas self.hacerLavado(prelavado, secado, encerado) # Se guarda la fase inicial fases_visitadas = [self.fase] # Mientras el lavadero est\u00e9 ocupado, seguimos avanzando fases while self.ocupado: # Medida de seguridad para evitar bucles infinitos # en caso de que exista un error en la l\u00f3gica if len(fases_visitadas) > 15: raise Exception( \"Bucle infinito detectado en la simulaci\u00f3n de fases.\" ) # Avanzamos a la siguiente fase self.avanzarFase() # Guardamos la nueva fase alcanzada fases_visitadas.append(self.fase) # Devolvemos la lista completa de fases recorridas return fases_visitadas","title":"Aqu\u00ed est\u00e1 el C\u00f3digo Comentado"},{"location":"reflexion/","text":"","title":"Reflexi\u00f3n"},{"location":"sandbox/","text":"","title":"Ejecuci\u00f3n en Sandbox"}]}