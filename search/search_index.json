{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PPS Unidad 1 \u2013 Tarea RA1 Carlos Castillo En esta p\u00e1gina se recoge la estructura y acceso a la documentaci\u00f3n de la Tarea RA1. 1. Elementos de Python En este apartado se documentan los elementos de Python utilizados en la pr\u00e1ctica, as\u00ed como el c\u00f3digo comentado desarrollado. Desarrollo completo en: Elementos de Python 2. Ejecuci\u00f3n y Depuraci\u00f3n Se describen los problemas encontrados durante la ejecuci\u00f3n del c\u00f3digo y el proceso de depuraci\u00f3n seguido para solucionarlos, incluyendo capturas de pantalla. Desarrollo completo en: Ejecuci\u00f3n y Depuraci\u00f3n 3. Pruebas En este apartado se explican las pruebas realizadas, los errores detectados, el c\u00f3digo de las pruebas y su ejecuci\u00f3n en el IDE. Desarrollo completo en: Pruebas 4. Ejecuci\u00f3n en Sandbox Se detalla el proceso de ejecuci\u00f3n del programa en un entorno Sandbox, incluyendo capturas del proceso. Desarrollo completo en: Ejecuci\u00f3n en Sandbox 5. Reflexi\u00f3n sobre la infraestructura de seguridad de los lenguajes Reflexi\u00f3n personal sobre la seguridad de Python y su comparaci\u00f3n con otros lenguajes, en relaci\u00f3n con la ejecuci\u00f3n en entornos controlados. Desarrollo completo en: Reflexi\u00f3n","title":"Inicio"},{"location":"#pps-unidad-1-tarea-ra1","text":"Carlos Castillo En esta p\u00e1gina se recoge la estructura y acceso a la documentaci\u00f3n de la Tarea RA1.","title":"PPS Unidad 1 \u2013 Tarea RA1"},{"location":"#1-elementos-de-python","text":"En este apartado se documentan los elementos de Python utilizados en la pr\u00e1ctica, as\u00ed como el c\u00f3digo comentado desarrollado. Desarrollo completo en: Elementos de Python","title":"1. Elementos de Python"},{"location":"#2-ejecucion-y-depuracion","text":"Se describen los problemas encontrados durante la ejecuci\u00f3n del c\u00f3digo y el proceso de depuraci\u00f3n seguido para solucionarlos, incluyendo capturas de pantalla. Desarrollo completo en: Ejecuci\u00f3n y Depuraci\u00f3n","title":"2. Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"#3-pruebas","text":"En este apartado se explican las pruebas realizadas, los errores detectados, el c\u00f3digo de las pruebas y su ejecuci\u00f3n en el IDE. Desarrollo completo en: Pruebas","title":"3. Pruebas"},{"location":"#4-ejecucion-en-sandbox","text":"Se detalla el proceso de ejecuci\u00f3n del programa en un entorno Sandbox, incluyendo capturas del proceso. Desarrollo completo en: Ejecuci\u00f3n en Sandbox","title":"4. Ejecuci\u00f3n en Sandbox"},{"location":"#5-reflexion-sobre-la-infraestructura-de-seguridad-de-los-lenguajes","text":"Reflexi\u00f3n personal sobre la seguridad de Python y su comparaci\u00f3n con otros lenguajes, en relaci\u00f3n con la ejecuci\u00f3n en entornos controlados. Desarrollo completo en: Reflexi\u00f3n","title":"5. Reflexi\u00f3n sobre la infraestructura de seguridad de los lenguajes"},{"location":"ejecucion/","text":"","title":"Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"pruebas/","text":"","title":"Pruebas"},{"location":"python/","text":"lavadero.py class Lavadero: \"\"\" Clase encargada de gestionar el ciclo de vida y la l\u00f3gica de negocio de un t\u00fanel de lavado. Implementa el control de estados, la gesti\u00f3n de ingresos y la validaci\u00f3n de servicios. \"\"\" # Definici\u00f3n de constantes para representar los estados del sistema. # El uso de constantes facilita el mantenimiento y evita errores por tipos de datos m\u00e1gicos. FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 def __init__(self): \"\"\" Constructor de la clase. Inicializa los atributos privados y asegura que el sistema comience en un estado consistente (Inactivo y sin ingresos). \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() # Implementaci\u00f3n de decoradores @property para garantizar el encapsulamiento. # Permiten el acceso de solo lectura a los atributos privados desde el exterior. @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado def terminar(self): \"\"\" Restablece todos los par\u00e1metros operativos del lavadero a sus valores por defecto, finalizando cualquier proceso activo. \"\"\" self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Configura e inicia un nuevo proceso de lavado tras validar las reglas de negocio. :raises RuntimeError: Si se intenta iniciar un servicio estando el sistema ocupado. :raises ValueError: Si la combinaci\u00f3n de servicios seleccionada es incompatible. \"\"\" # Validaci\u00f3n de disponibilidad del sistema (Requisito 3). if self.__ocupado: raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") # Validaci\u00f3n de dependencia de servicios (Requisito 2: Encerado requiere secado manual). if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado def _cobrar(self): \"\"\" M\u00e9todo interno para el c\u00e1lculo de tarifas seg\u00fan los servicios adicionales contratados. Aplica los costes estipulados y actualiza el acumulado de ingresos globales. \"\"\" coste_lavado = 5.00 # Tarifa base est\u00e1ndar. if self.__prelavado_a_mano: coste_lavado += 1.50 # Suplemento por prelavado manual. if self.__secado_a_mano: coste_lavado += 1.20 # Suplemento por secado manual. if self.__encerado: coste_lavado += 1.00 # Suplemento por encerado. self.__ingresos += coste_lavado return coste_lavado def avanzarFase(self): \"\"\" Gestiona la transici\u00f3n de estados dentro del flujo de trabajo del lavadero. Controla la secuencia l\u00f3gica del proceso en funci\u00f3n de la configuraci\u00f3n inicial. \"\"\" if not self.__ocupado: return # Inicio del flujo: Transici\u00f3n de inactividad a facturaci\u00f3n. if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") # Determinaci\u00f3n de la siguiente etapa tras el cobro. elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS # Bifurcaci\u00f3n del flujo seg\u00fan el tipo de secado seleccionado. elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO # Estados finales que conllevan la liberaci\u00f3n de los recursos del sistema. elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() elif self.__fase == self.FASE_SECADO_MANO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}.\") def imprimir_fase(self): \"\"\"Mapea el valor num\u00e9rico del estado actual a su descripci\u00f3n textual correspondiente.\"\"\" fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") def imprimir_estado(self): \"\"\"Genera un informe visual por consola detallando los par\u00e1metros actuales del objeto.\"\"\" print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\")","title":"Elementos de Python"},{"location":"python/#lavaderopy","text":"class Lavadero: \"\"\" Clase encargada de gestionar el ciclo de vida y la l\u00f3gica de negocio de un t\u00fanel de lavado. Implementa el control de estados, la gesti\u00f3n de ingresos y la validaci\u00f3n de servicios. \"\"\" # Definici\u00f3n de constantes para representar los estados del sistema. # El uso de constantes facilita el mantenimiento y evita errores por tipos de datos m\u00e1gicos. FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 def __init__(self): \"\"\" Constructor de la clase. Inicializa los atributos privados y asegura que el sistema comience en un estado consistente (Inactivo y sin ingresos). \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() # Implementaci\u00f3n de decoradores @property para garantizar el encapsulamiento. # Permiten el acceso de solo lectura a los atributos privados desde el exterior. @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado def terminar(self): \"\"\" Restablece todos los par\u00e1metros operativos del lavadero a sus valores por defecto, finalizando cualquier proceso activo. \"\"\" self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Configura e inicia un nuevo proceso de lavado tras validar las reglas de negocio. :raises RuntimeError: Si se intenta iniciar un servicio estando el sistema ocupado. :raises ValueError: Si la combinaci\u00f3n de servicios seleccionada es incompatible. \"\"\" # Validaci\u00f3n de disponibilidad del sistema (Requisito 3). if self.__ocupado: raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") # Validaci\u00f3n de dependencia de servicios (Requisito 2: Encerado requiere secado manual). if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado def _cobrar(self): \"\"\" M\u00e9todo interno para el c\u00e1lculo de tarifas seg\u00fan los servicios adicionales contratados. Aplica los costes estipulados y actualiza el acumulado de ingresos globales. \"\"\" coste_lavado = 5.00 # Tarifa base est\u00e1ndar. if self.__prelavado_a_mano: coste_lavado += 1.50 # Suplemento por prelavado manual. if self.__secado_a_mano: coste_lavado += 1.20 # Suplemento por secado manual. if self.__encerado: coste_lavado += 1.00 # Suplemento por encerado. self.__ingresos += coste_lavado return coste_lavado def avanzarFase(self): \"\"\" Gestiona la transici\u00f3n de estados dentro del flujo de trabajo del lavadero. Controla la secuencia l\u00f3gica del proceso en funci\u00f3n de la configuraci\u00f3n inicial. \"\"\" if not self.__ocupado: return # Inicio del flujo: Transici\u00f3n de inactividad a facturaci\u00f3n. if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") # Determinaci\u00f3n de la siguiente etapa tras el cobro. elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS # Bifurcaci\u00f3n del flujo seg\u00fan el tipo de secado seleccionado. elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO # Estados finales que conllevan la liberaci\u00f3n de los recursos del sistema. elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() elif self.__fase == self.FASE_SECADO_MANO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}.\") def imprimir_fase(self): \"\"\"Mapea el valor num\u00e9rico del estado actual a su descripci\u00f3n textual correspondiente.\"\"\" fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") def imprimir_estado(self): \"\"\"Genera un informe visual por consola detallando los par\u00e1metros actuales del objeto.\"\"\" print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\")","title":"lavadero.py"},{"location":"reflexion/","text":"","title":"Reflexi\u00f3n"},{"location":"sandbox/","text":"","title":"Ejecuci\u00f3n en Sandbox"}]}