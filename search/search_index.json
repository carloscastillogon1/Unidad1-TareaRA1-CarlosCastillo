{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PPS Unidad 1 \u2013 Tarea RA1","text":"<p>Carlos Castillo</p> <p>En esta p\u00e1gina se recoge la estructura y acceso a la documentaci\u00f3n de la Tarea RA1.</p>"},{"location":"#indice","title":"\u00cdndice","text":"<ul> <li>Elementos de Python</li> <li>Ejecuci\u00f3n y Depuraci\u00f3n</li> <li>Pruebas</li> <li>Ejecuci\u00f3n en Sandbox</li> <li>Reflexi\u00f3n</li> </ul>"},{"location":"ejecucion/","title":"En esta secci\u00f3n. lo que vamos a realizar es la depuraci\u00f3n del c\u00f3digo y la ejecuci\u00f3n del mismo, de esta forma, podremos observar sus errores y corregirlos.","text":"<p>El primer paso ser\u00e1 abrir el Visual Studio Code. Una vez dentro, seleccionaremos la carpeta donde se encuentra la app:</p> <p></p> <p>Una vez abierta la carpeta donde se encuentra la app, la cual es main_app.py, lo que haremos ser\u00e1 ejecutarla, para ello, clickamos en el boton de play situado en la esquina superior derecha:</p> <p></p> <p>Pero antes de ejecutarlo, lo que debemos hacer es leer las premisas con las cuales se ha dise\u00f1ado la app, y corregir los errores que encontremos en el c\u00f3digo, debido a que si ejecutamos la app as\u00ed, nos saldr\u00e1 un error bastante r\u00e1pido. </p>"},{"location":"ejecucion/#solucion-de-errores","title":"Soluci\u00f3n de errores:","text":"<p>Por lo tanto, lo que vamos a hacer es corregir los errores, y despu\u00e9s, probaremos a ejecutar la app a ver si todo funciona correctamente:</p> <ul> <li> <p>Error 1: RuntimeError</p> <p></p> </li> </ul> <p>Como podemos observar, aparece un RuntimeError cuando el lavadero est\u00e1 ocupado, mientras las premisas con las cuales se crearon la app nos indica: Cuando se    intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una ValueError.</p> <p>Para corregir este error, simplemente cambiamos RuntimeError por ValueError:</p> <p></p> <ul> <li>Error 2: Error en tarifas de secado a mano y encerado</li> </ul> <p>Seg\u00fan las premisas del enunciado del ejercicio, la suma de lavado + secado a mano reportar\u00eda al lavadero unas ganancias de 6\u20ac, si a esto le a\u00f1adimos    encerado, ser\u00eda un total de 7,20\u20ac.</p> <p>Esto quiere decir que el precio del secado a mano debe ser de 1\u20ac, mientras que el del encerado debe ser de 1,20\u20ac.</p> <p>El error est\u00e1 en que en el c\u00f3digo, las tarifas vienen al rev\u00e9s, costando 1,20\u20ac el secado a mano y 1\u20ac el encerado:</p> <p></p> <p>Para corregir este error, simplemente lo que haremos ser\u00e1 cambiar estos valores, como antes he mencionado, el valor del secado a mano le corresponde al valor    del encerado y viceversa:</p> <p></p> <ul> <li>Error 3: Error de l\u00f3gica en fase de secado a mano y autom\u00e1tico</li> </ul> <p>En el c\u00f3digo, aparece un error en la transici\u00f3n de una fase a otra. Seg\u00fan el c\u00f3digo, cuando estamos en la fase de rodillos, si seleccionamos secado a    mano, nos lleva a secado autom\u00e1tico. Esto en ning\u00fan caso deber\u00eda de ser as\u00ed, puesto que si seleccionamos secado a mano, deber\u00edamos ir a    secado    a mano:</p> <p></p> <p>Para solucionar esto, cambiaremos la parte donde se encuentra self.__fase = self.FASE_SECADO_AUTOMATICO y la pondremos donde est\u00e1 el self.__fase =    self.FASE_SECADO_MANO:</p> <p></p> <ul> <li>Error 4: Interrupci\u00f3n hacia el encerado</li> </ul> <p>Como podemos observar en el c\u00f3digo proporcionado, siempre que seleccionamos secado a mano, se llama a terminar. Esto no deber\u00eda ser as\u00ed, ya que nos    deber\u00eda dar opci\u00f3n a pasar al encerado:</p> <p></p> <p>Para solucionarlo, debemos a\u00f1adir la opci\u00f3n de que nos deje acceder a la fase 8, la cual es encerado:</p> <p></p> <ul> <li>Error 5: Funci\u00f3n ejecutar_y_obtener_fases est\u00e1 fuera de la clase</li> </ul> <p>Aunque como menciona el c\u00f3digo, esta funci\u00f3n no es parte del lavadero real, a\u00fan as\u00ed, no se encuentra identada a la clase. \u00bfQu\u00e9 problema ocasionar\u00e1 esto? Pues    Que al usar self, el int\u00e9rprete fallar\u00e1 porque no la reconoce como parte de Lavadero:</p> <p></p> <p>Para solucionar esto, debemos mover el bloque hacia la derecha para que coincida con la identaci\u00f3n de la clase:</p> <p></p> <p>Como podemos observar, ahora s\u00ed se encuentra bien identado y ser\u00e1 reconocible.</p> <ul> <li>Error 6: Referencia a M\u00e9todo Inexistente</li> </ul> <p>En este mismo bloque de c\u00f3digo que acabamos de corregir, se hace referencia a un m\u00f3dulo que no existe, el cual es _hacer_lavado. Este m\u00f3dulo es    incorrecto, el m\u00f3dulo correcto ser\u00eda hacerLavado:</p> <p></p> <p>Para corregirlo, simplemente lo cambiamos a hacerLavado</p> <p></p>"},{"location":"ejecucion/#ejecucion-del-codigo","title":"Ejecuci\u00f3n del c\u00f3digo","text":"<p>Con las correcciones ya hechas, podemos pasar a ejecutar el c\u00f3digo, a ver si nos proporciona fallos. Para ello, debemos ir al main_app.py, el cual   ejecutar\u00e1 la aplicaci\u00f3n bas\u00e1ndose en el c\u00f3digo de Lavadero. Despu\u00e9s, haremos click en el bot\u00f3n de play situado en la esquina derecha superior de Visual:</p> <p></p> <p>Una vez ejecutado, podemos observar 3 cosas. Vamos por partes:</p> <ol> <li> <p>\u00c9xito en la L\u00f3gica de Negocio (Ejemplos 1 y 2)</p> <p>Ejemplo 1 (Todo incluido): Ha pasado por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. Los ingresos han sido 8.70 \u20ac. Esto coincide exactamente con las premisas  del enunciado (5.00 base + 1.50 prelavado + 1.00 secado + 1.20 encerado).</p> <p>Ejemplo 2 (Sin extras): Ha pasado por 0, 1, 3, 4, 5, 6, 0. Ha saltado la fase 2 (prelavado) y la fase 7-8 (manual/encerado), yendo directo a la 6  (autom\u00e1tico). Los ingresos acumulados subieron a 13.70 \u20ac (8.70 + 5.00). Esto quiere decir que la acumulaci\u00f3n funciona.</p> <p></p> <p></p> </li> </ol> <ol> <li> <p>Validaci\u00f3n de Errores (Ejemplo 3)</p> <p>El programa ha detectado que el cliente quer\u00eda encerado sin secado a mano y ha lanzado el ValueError con el mensaje: \"No se puede encerar el coche sin  secado a mano\". Esto demuestra que la correcci\u00f3n que hemos hecho con anterioridad al RuntimeError es correcta y lanza el mensaje correcto.</p> <p></p> </li> </ol> <ol> <li> <p>El error de Python (Ejemplo 4)</p> <p>Inesperadamente, el programa se ha detenido por un TypeError. Python nos se\u00f1ala: missing 1 required positional argument: 'encerado' Esto puede deberse a un  error en el main_app.py, el cual no hemos comprobado antes de ejecutarlo.</p> <p></p> <p>Echando un vistazo al main_app.py, parece ser que sucede porque la funci\u00f3n  ejecutarSimulacion espera 4 cosas y el ejemplo 4 solo le da 3. Habr\u00eda que corregir la siguiente l\u00ednea del main_app.py:</p> <p></p> <p>Parece ser que est\u00e1 definido as\u00ed: def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado):</p> <p>Esto quiere decir que se nos obliga a proporcionarle 4 argumentos s\u00ed o s\u00ed, pero en el Ejemplo 4 s\u00f3lo sxe proporcionan 3, ya que encerado=false. Por lo  tanto, va a dar un error ya que se queda esperando a dicho argumento.</p> <p>Para solucionar esto, lo que haremos es modificar dicha l\u00ednea, especificando que encerado tambi\u00e9n puede ser false:</p> <p></p> </li> </ol> <p>Ahora, podremos pasar a ejecutarlo. Con esta soluci\u00f3n que hemos realizado en esa l\u00ednea, no nos deber\u00eda dar ning\u00fan error y se deber\u00eda ejecutar al completo:</p> <p></p> <p>Como podemos comprobar, hemos logrado solucionar el error con el Ejemplo 4. </p> <ul> <li> <p>Al hacer el par\u00e1metro opcional (encerado=False), el programa ya no se   detiene.</p> </li> <li> <p>Los ingresos acumulados tambi\u00e9n son correctos, el Ejemplo 3 no suma dinero porque el error se detecta antes de cobrar, lo cual es el comportamiento   correcto en un sistema de cobro real.</p> </li> <li> <p>Todas las fases coinciden con las premisas que se indican en el enunciado.</p> </li> </ul>"},{"location":"pruebas/","title":"En este apartado, lo que vamos a realizar es una serie de test bas\u00e1ndonos en el enunciado de la tarea, el cual nos menciona una serie de 14 pruebas.","text":"<p>En la carpeta proporcionada en la tarea, se nos proporciona un ejemplo de test, pero este no nos servir\u00e1 de mucho, simplemente para fijarnos en como desarrollar m\u00e1s o menos las pruebas.</p> <p>Se nos menciona que el c\u00f3digo contiene errores, pero estos errores ya los hemos solucionado previamente, lo cual quiere decir que las pruebas no deber\u00edan arrojar ni un solo error, por lo que dichas pruebas nos van a servir para comprobar que el c\u00f3digo est\u00e1 perfectamente estructurado.</p>"},{"location":"pruebas/#14-test-basandonos-en-los-enunciados","title":"14 test bas\u00e1ndonos en los enunciados","text":"<p>1. Cuando se crea un lavadero, \u00e9ste no tiene ingresos, no est\u00e1 ocupado, est\u00e1 en fase 0 y todas las opciones de lavado    (prelavado a mano, secado a mano y encerado) est\u00e1n puestas a false.</p> <p></p> <p>2. Cuando se intenta comprar un lavado con encerado pero sin secado a mano, se produce una ValueError.</p> <p></p> <p>3. Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una ValueError.</p> <p></p> <p>4.Si seleccionamos un lavado con prelavado a mano, los ingresos de lavadero son 6,50\u20ac.</p> <p></p> <p>5.Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac.</p> <p></p> <p>6.Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac.</p> <p></p> <p>7.Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac.</p> <p></p> <p>8.Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac.</p> <p></p> <p>9.Si seleccionamos un lavado sin extras y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 6, 0.</p> <p></p> <p>10.Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0.</p> <p></p> <p>11.Si seleccionamos un lavado con secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 0.</p> <p></p> <p>12.Si seleccionamos un lavado con secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0.</p> <p></p> <p>13.Si seleccionamos un lavado con prelavado a mano y secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 0.</p> <p></p> <p>14.Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0.</p> <p></p>"},{"location":"pruebas/#ejecucion-del-test","title":"Ejecuci\u00f3n del test","text":"<p>Como he mencionado antes, vamos a ejecutar el test para verificar que todas las corrwcciones que hemos realizado con anterioridad dan soluci\u00f3n a todos los problemas.</p> <p>Para ejecutarlo, abriremos la consola, y escribiremos py test_lavadero_unittest.py -v:</p> <p></p> <p>Como podemos observar, todo ha funcionado correctamente, lo cual indica que hemos solventado todos los errores que conten\u00eda el c\u00f3digo en un principio, y por lo tanto, el programa estar\u00eda listo para ponerse en marcha en un negocio real.</p> <p>Los 14 test se han ejecutado con \u00e9xito, los tests de \"flujo\" confirman que el coche pasa exactamente por las fases que debe seg\u00fan los extras elegidos y no se desv\u00edan a otros, los mensajes de (COBRADO: ...) que podemos observar al final confirman que los precios (6.50\u20ac, 7.20\u20ac, 8.70\u20ac, etc.) son los correctos tras las correcciones que he realizado anteriormente, los tests 2 y 3 confirman que el programa lanza las excepciones adecuadas cuando se intenta hacer algo prohibido (como encerar sin secar).</p>"},{"location":"python/","title":"C\u00f3digo Python \u2013 Simulaci\u00f3n de un Lavadero de Coches","text":""},{"location":"python/#introduccion","title":"Introducci\u00f3n","text":"<p>Este documento muestra el c\u00f3digo comentado del archivo <code>lavadero.py</code>. El objetivo del programa es simular el comportamiento de un t\u00fanel de lavado de coches, controlando:</p> <ul> <li>El estado del lavadero</li> <li>Las fases del lavado</li> <li>Las reglas de negocio</li> <li>El c\u00e1lculo de ingresos</li> </ul>"},{"location":"python/#conceptos-clave-del-diseno","title":"Conceptos clave del dise\u00f1o","text":"<p>Antes de analizar el c\u00f3digo, es importante comprender los siguientes conceptos:</p> <ul> <li>El lavadero solo puede atender a un coche a la vez</li> <li>Cada lavado sigue una secuencia fija de fases</li> <li>Algunas fases son opcionales</li> <li>El precio final depende de los servicios seleccionados</li> </ul>"},{"location":"python/#aqui-esta-el-codigo-comentado","title":"Aqu\u00ed est\u00e1 el C\u00f3digo Comentado","text":"<p>A continuaci\u00f3n se muestra el c\u00f3digo completo del lavadero, acompa\u00f1ado de comentarios detallados que explican el funcionamiento de cada parte.</p> <p>```</p>"},{"location":"python/#lavaderopy","title":"lavadero.py","text":"<p>class Lavadero:     \"\"\"     Clase que representa un lavadero de coches.     Controla el estado del lavado, las fases y los ingresos.     \"\"\"</p> <pre><code># Constantes de clase que representan las distintas fases del lavado\nFASE_INACTIVO = 0\nFASE_COBRANDO = 1\nFASE_PRELAVADO_MANO = 2\nFASE_ECHANDO_AGUA = 3\nFASE_ENJABONANDO = 4\nFASE_RODILLOS = 5\nFASE_SECADO_AUTOMATICO = 6\nFASE_SECADO_MANO = 7\nFASE_ENCERADO = 8\n\ndef __init__(self):\n    \"\"\"\n    Constructor de la clase.\n    Se ejecuta autom\u00e1ticamente al crear un objeto Lavadero.\n    Inicializa los atributos del objeto.\n    \"\"\"\n\n    # Atributo privado que guarda el total de ingresos del lavadero\n    self.__ingresos = 0.0\n\n    # Atributo privado que indica la fase actual del lavado\n    self.__fase = self.FASE_INACTIVO\n\n    # Indica si el lavadero est\u00e1 ocupado o no\n    self.__ocupado = False\n\n    # Opciones del lavado (todas empiezan desactivadas)\n    self.__prelavado_a_mano = False\n    self.__secado_a_mano = False\n    self.__encerado = False\n\n    # Se asegura de que el lavadero empieza en estado inactivo\n    self.terminar()\n\n# Propiedad que permite consultar la fase actual sin modificarla\n@property\ndef fase(self):\n    return self.__fase\n\n# Propiedad que devuelve los ingresos acumulados\n@property\ndef ingresos(self):\n    return self.__ingresos\n\n# Propiedad que indica si el lavadero est\u00e1 ocupado\n@property\ndef ocupado(self):\n    return self.__ocupado\n\n# Propiedad que indica si se ha elegido prelavado a mano\n@property\ndef prelavado_a_mano(self):\n    return self.__prelavado_a_mano\n\n# Propiedad que indica si se ha elegido secado a mano\n@property\ndef secado_a_mano(self):\n    return self.__secado_a_mano\n\n# Propiedad que indica si se ha elegido encerado\n@property\ndef encerado(self):\n    return self.__encerado\n\ndef terminar(self):\n    \"\"\"\n    M\u00e9todo que finaliza el lavado y reinicia el estado del lavadero.\n    \"\"\"\n\n    # Se vuelve a la fase inactiva\n    self.__fase = self.FASE_INACTIVO\n\n    # El lavadero deja de estar ocupado\n    self.__ocupado = False\n\n    # Se desactivan todas las opciones del lavado\n    self.__prelavado_a_mano = False\n    self.__secado_a_mano = False\n    self.__encerado = False\n\ndef hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado):\n    \"\"\"\n    Inicia un nuevo lavado.\n    Comprueba que se cumplan las reglas del negocio antes de empezar.\n    \"\"\"\n\n    # Si el lavadero ya est\u00e1 ocupado, no se puede iniciar otro lavado\n    if self.__ocupado:\n        raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\")\n\n    # No se permite encerar si no se ha seleccionado secado a mano\n    if not secado_a_mano and encerado:\n        raise ValueError(\"No se puede encerar el coche sin secado a mano\")\n\n    # Se inicia el lavado poniendo el lavadero como ocupado\n    self.__fase = self.FASE_INACTIVO\n    self.__ocupado = True\n\n    # Se guardan las opciones elegidas para este lavado\n    self.__prelavado_a_mano = prelavado_a_mano\n    self.__secado_a_mano = secado_a_mano\n    self.__encerado = encerado\n\ndef _cobrar(self):\n    \"\"\"\n    M\u00e9todo interno que calcula el precio del lavado\n    y suma el importe a los ingresos del lavadero.\n    \"\"\"\n\n    # Precio base del lavado\n    coste_lavado = 5.00\n\n    # Si se ha elegido prelavado a mano, se suma su coste\n    if self.__prelavado_a_mano:\n        coste_lavado += 1.50\n\n    # Si se ha elegido secado a mano, se suma su coste\n    if self.__secado_a_mano:\n        coste_lavado += 1.20\n\n    # Si se ha elegido encerado, se suma su coste\n    if self.__encerado:\n        coste_lavado += 1.00\n\n    # Se a\u00f1ade el coste total a los ingresos acumulados\n    self.__ingresos += coste_lavado\n\n    # Se devuelve el coste del lavado actual\n    return coste_lavado\n\ndef avanzarFase(self):\n    \"\"\"\n    Avanza el lavado a la siguiente fase seg\u00fan el estado actual.\n    \"\"\"\n\n    # Si el lavadero no est\u00e1 ocupado, no se hace nada\n    if not self.__ocupado:\n        return\n\n    # Fase inicial: se cobra el lavado\n    if self.__fase == self.FASE_INACTIVO:\n        coste_cobrado = self._cobrar()\n        self.__fase = self.FASE_COBRANDO\n        print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\")\n\n    # Despu\u00e9s de cobrar, se decide si hay prelavado a mano\n    elif self.__fase == self.FASE_COBRANDO:\n        if self.__prelavado_a_mano:\n            self.__fase = self.FASE_PRELAVADO_MANO\n        else:\n            self.__fase = self.FASE_ECHANDO_AGUA\n\n    # Transiciones entre fases del lavado\n    elif self.__fase == self.FASE_PRELAVADO_MANO:\n        self.__fase = self.FASE_ECHANDO_AGUA\n\n    elif self.__fase == self.FASE_ECHANDO_AGUA:\n        self.__fase = self.FASE_ENJABONANDO\n\n    elif self.__fase == self.FASE_ENJABONANDO:\n        self.__fase = self.FASE_RODILLOS\n\n    elif self.__fase == self.FASE_RODILLOS:\n        if self.__secado_a_mano:\n            self.__fase = self.FASE_SECADO_AUTOMATICO\n        else:\n            self.__fase = self.FASE_SECADO_MANO\n\n    # Al terminar el secado, el lavado finaliza\n    elif self.__fase == self.FASE_SECADO_AUTOMATICO:\n        self.terminar()\n\n    elif self.__fase == self.FASE_SECADO_MANO:\n        self.terminar()\n\n    elif self.__fase == self.FASE_ENCERADO:\n        self.terminar()\n\n    # Control de errores por si aparece un estado no v\u00e1lido\n    else:\n        raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}\")\n\ndef imprimir_fase(self):\n    \"\"\"\n    Muestra por pantalla el nombre de la fase actual.\n    \"\"\"\n\n    # Diccionario que relaciona cada fase con un texto descriptivo\n    fases_map = {\n        self.FASE_INACTIVO: \"0 - Inactivo\",\n        self.FASE_COBRANDO: \"1 - Cobrando\",\n        self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\",\n        self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\",\n        self.FASE_ENJABONANDO: \"4 - Enjabonando\",\n        self.FASE_RODILLOS: \"5 - Pasando rodillos\",\n        self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\",\n        self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\",\n        self.FASE_ENCERADO: \"8 - Encerando a mano\",\n    }\n\n    # Se imprime la fase actual\n    print(fases_map.get(self.__fase, \"Estado no v\u00e1lido\"), end=\"\")\n\ndef imprimir_estado(self):\n    \"\"\"\n    Imprime por pantalla el estado completo del lavadero.\n    \"\"\"\n\n    print(\"----------------------------------------\")\n    print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\")\n    print(f\"Ocupado: {self.ocupado}\")\n    print(f\"Prelavado a mano: {self.prelavado_a_mano}\")\n    print(f\"Secado a mano: {self.secado_a_mano}\")\n    print(f\"Encerado: {self.encerado}\")\n    print(\"Fase: \", end=\"\")\n    self.imprimir_fase()\n    print(\"\\n----------------------------------------\")\n\n\n# M\u00c9TODO AUXILIAR PARA PRUEBAS / TESTS: Este m\u00e9todo NO forma parte del funcionamiento real del lavadero. Su \u00fanico prop\u00f3sito es facilitar pruebas unitarias y\n# comprobaciones autom\u00e1ticas del flujo de estados del sistema.\n\ndef ejecutar_y_obtener_fases(self, prelavado, secado, encerado):\n    \"\"\"\n    Ejecuta un ciclo completo de lavado y devuelve\n    una lista con todas las fases visitadas.\n\n    Este m\u00e9todo es muy \u00fatil para:\n    - Verificar que el flujo de estados es correcto\n    - Detectar errores en la m\u00e1quina de estados\n    - Realizar pruebas unitarias automatizadas\n\n    Par\u00e1metros:\n    - prelavado: indica si hay prelavado a mano\n    - secado: indica si hay secado a mano\n    - encerado: indica si hay encerado\n\n    Retorna:\n    - Lista de enteros con las fases visitadas\n    \"\"\"\n\n    # Se inicia el lavado con las opciones indicadas\n    self.hacerLavado(prelavado, secado, encerado)\n\n    # Se guarda la fase inicial\n    fases_visitadas = [self.fase]\n\n    # Mientras el lavadero est\u00e9 ocupado, seguimos avanzando fases\n    while self.ocupado:\n\n        # Medida de seguridad para evitar bucles infinitos\n        # en caso de que exista un error en la l\u00f3gica\n        if len(fases_visitadas) &gt; 15:\n            raise Exception(\n                \"Bucle infinito detectado en la simulaci\u00f3n de fases.\"\n            )\n\n        # Avanzamos a la siguiente fase\n        self.avanzarFase()\n\n        # Guardamos la nueva fase alcanzada\n        fases_visitadas.append(self.fase)\n\n    # Devolvemos la lista completa de fases recorridas\n    return fases_visitadas\n</code></pre>"},{"location":"reflexion/","title":"Reflexi\u00f3n","text":""},{"location":"reflexion/#reflexion-personal-comparacion-de-la-infraestructura-de-seguridad-de-los-lenguajes","title":"Reflexi\u00f3n personal: Comparaci\u00f3n de la infraestructura de seguridad de los lenguajes","text":"<p>Despu\u00e9s de desarrollar esta aplicaci\u00f3n y estudiar la teor\u00eda, queda claro que la seguridad de un programa empieza por el lenguaje que elegimos. No todos los lenguajes protegen el sistema de la misma forma:</p> <ol> <li>La gesti\u00f3n de la memoria</li> </ol> <p>Existen lenguajes como C o C++ donde el programador tiene el control total de la memoria del ordenador. Esto los hace muy r\u00e1pidos, pero tambi\u00e9n muy peligrosos.  Un error com\u00fan, como el desbordamiento de b\u00fafer, puede permitir que un atacante tome el control del sistema. Si se hubiera programado el lavadero en C, cualquier falloal introducir datos podr\u00eda haber bloqueado la m\u00e1quina.</p> <p>En cambio, Python (el lenguaje que se ha usado) gestiona la memoria de forma autom\u00e1tica. Tiene un sistema llamado Garbage Collector que se encarga de limpiar lo que no se usa y evita que el programador cometa esos errores graves de memoria. Por eso se dice que es un lenguaje \"seguro de memoria\".</p> <ol> <li>Lenguajes modernos y seguros (Rust)</li> </ol> <p>Es interesante mencionar lenguajes m\u00e1s nuevos como Rust. Este lenguaje intenta se superior a los dos antes mencionados: es tan r\u00e1pido como C pero mucho m\u00e1s seguro. Su dise\u00f1o impide que el programa se ejecute si detecta que hay un riesgo de seguridad en la memoria. Es una opci\u00f3n que se est\u00e1 usando mucho hoy en d\u00eda para infraestructuras cr\u00edticas.</p> <ol> <li>Tipado de datos</li> </ol> <p>Tambi\u00e9n influye c\u00f3mo el lenguaje trata los datos:</p> <ul> <li> <p>Lenguajes como Python: Son flexibles, pero a veces los errores de tipo aparecen solo cuando el programa ya se est\u00e1 ejecutando   (por ejemplo, si el usuario escribe letras donde se espera un n\u00famero).</p> </li> <li> <p>Lenguajes como Java: Son m\u00e1s estrictos y te obligan a definir cada dato desde el principio, lo que ayuda a evitar fallos l\u00f3gicos antes de que el programa se   ponga en marcha.</p> </li> </ul>"},{"location":"reflexion/#conclusion-final","title":"Conclusi\u00f3n final","text":"<p>En mi opini\u00f3n, ning\u00fan lenguaje es 100% invulnerable, pero usar Python facilita mucho crear un c\u00f3digo robusto. Me ha permitido centrarme en los errores del usuario (el manejo de excepciones) sin tener que preocuparme por fallos complejos del sistema operativo.</p> <p>Sin embargo, lo m\u00e1s importante que nos ense\u00f1a esta pr\u00e1ctica es que la seguridad debe ir por capas. Aunque usemos un lenguaje seguro como Python, es necesario usar  herramientas extras como, por ejemplo, alguna Sandbox. La combinaci\u00f3n de un lenguaje con gesti\u00f3n autom\u00e1tica de memoria y un entorno aislado por contenedores es lo que realmente nos ha garantizado una puesta en producci\u00f3n segura en esta pr\u00e1ctica.</p>"},{"location":"sandbox/","title":"En este apartado, ejecutaremos el c\u00f3digo en una sandbox.","text":"<p>Se utiliza una Sandbox para ejecutar una aplicaci\u00f3n de forma m\u00e1s segura. Como cualquier programa nuevo puede tener fallos o errores de seguridad, el sandbox funciona como una \u201cbarrera\u201d que limita lo que la aplicaci\u00f3n puede hacer. De esta manera, se restringe el acceso al sistema y a los archivos importantes, evitando  que un posible ataque o fallo afecte al sistema principal de la computadora.</p> <p>En mi caso, he escogido Docker, la cual para esta pr\u00e1ctica nos vale como sandbox. Docker permite ejecutar aplicaciones dentro de entornos aislados y controlados. Cada contenedor incluye la aplicaci\u00f3n junto con todas sus dependencias, lo que garantiza que se ejecute de forma consistente independientemente del sistema anfitri\u00f3n. Este aislamiento limita el acceso del contenedor a los recursos del sistema, reduciendo los riesgos de seguridad y evitando que una aplicaci\u00f3n con fallos o comportamiento malicioso afecte al sistema principal.</p> <p>En mi caso, Docker se utilizar\u00e1 sobre un sistema Kali Linux, lo que permite crear y gestionar entornos aislados de manera eficiente para la ejecuci\u00f3n de herramientas o servicios espec\u00edficos. He elegido Docker porque facilita la creaci\u00f3n, despliegue y eliminaci\u00f3n de contenedores de forma r\u00e1pida, sin necesidad de configuraciones complejas. Adem\u00e1s, ofrece un buen equilibrio entre aislamiento, rendimiento y facilidad de uso, lo que lo convierte en una soluci\u00f3n adecuada para implementar medidas de seguridad y pruebas controladas dentro de Kali Linux.</p>"},{"location":"sandbox/#ejecucion-en-sandbox","title":"Ejecuci\u00f3n en Sandbox","text":"<p>Para ejecutarlo en la sandbox antes mencionada, Docker, simplemente debemos tener instalado Docker, que en caso de Kali, suele venir ya instalado. Despu\u00e9s, habr\u00eda que crear un Dockerfile en el cual vamos a configurar el contenedor Docker. Una vez configurado el Dockerfile, debemos ejecutar dos simples comandos.</p> <p>Dockerfile</p> <p></p> <p>Una vez creado el Dockerfile, har\u00e9 uso de los siguientes comandos:</p> <ul> <li>sudo docker build -t lavadero-sandbox .</li> </ul> <p></p> <ul> <li>sudo docker run --rm -it lavadero-sandbox</li> </ul> <p></p> <p></p> <p>Como podemos observar, la aplicaci\u00f3n se ha ejecutado correctamente en un entorno aislado. En este caso ha sido en un contenedor de Docker, el cual en ning\u00fan momento interact\u00faa con nuestro sistema, lo que nos quiere decir que si existiera alguna vulnerabilidad, \u00fanicamente afectar\u00eda al contenedor y no a nuestro sistema real. Esta pr\u00e1ctica es muy buena en un entorno de producci\u00f3n, ya que nos proporciona un buen nivel de seguridad.</p>"}]}